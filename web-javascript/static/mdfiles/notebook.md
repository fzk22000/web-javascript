# 《算法设计与分析》自学笔记
## 第一章 基础知识
### 1.1 intro
#### 计算思维与算法

>三种思维
> - 实验思维
> - 理论思维
> - 计算思维

##### 计算思维的过程步骤：
1. 建模
2. 抽象与分解
3. 自动化实现

算法能够训练计算思维，涉及到对问题的抽象、建模、设计好的解法、复杂性的控制

#### 课程介绍
##### 基本内容
- 组合算法设计的基本技术
- 算法分析的基本方法
- 计算复杂性理论的基本概念
- 用算法理论处理实际问题
- 学科新进展
![alt text](/static/mdfiles/images/image.png)
##### 考核方式
- 期中20%
- 期末40%
- 作业20%
- 小班考勤5%
- 小班平时表现15%

#### 引言：理论上的可计算与现实上的可计算
##### 什么是好的算法？
- 提高求解问题的效率
- 节省存储空间
##### 需要解决的问题

||||
|:---:|:---:|:---:|
|问题|寻找求解算法|算法设计技术|
|算法|算法的评价|算法分析技术|
|算法类|问题复杂度的评价|问题复杂性分析|
|问题类|能够求解的边界|计算复杂性理论|

##### 算法研究的重要性
计算复杂性理论的核心课题"P=NP?"是本世纪7个最重要的数学问题之一

##### 理论上的可计算：可计算性理论
- 研究目标
  - 确定什么问题是可计算的，即存在求解算法
- 合理的计算模型
  - 已有的：递归函数、Turing机、λ演算、Post系统等
  - 条件
    - 计算一个函数只要有限条指令
    - 每条指令可以有模型中的个有限个计算步骤完成
    - 指令执行的过程是确定的
  - 核心论题：Church-Turing论题
    - 如果一个函数在某个和合理的计算模型上可计算，那么他在Turing机上也是可计算的
  - 可计算性不依赖于计算模型的客观性质

##### 理论上与现实上的可计算性
![alt text](/static/mdfiles/images/image-1.png)
||||
|:-:|:-:|:-:|
|理论上可计算|算法至少具有指数时间|难解的|
|现实上可计算|多项式时间的算法|多项式时间可解的|
|高度并行可计算|对数多项式时间的算法|高度并行可解的|

### 1.2 算法与复杂度分析
#### 问题
##### 问题
需要回答的一般性提问,通常含有若干参数
##### 问题描述包含的内容
- 对问题参数的一般性描述
- 解满足的条件
##### 一个问题的实例
指对问题的参数的一组赋值
*一个问题是由他的全体实例构成的集合*
##### 常见问题举例
- 调度问题
  - 让所有客户等待总时间最少
  - 求解S的排列使得$\sum_{k=1}^{n} (n-k+1)t_{i_{k}}$最小
  - 目前好的做法是贪心
- 投资问题
  - m元钱投资给n个项目,最大化收益
  - $max\sum_{i=1}^{n}f_{i}(x_{i}),\sum_{i=1}^{n}x_{i}=m,x_{i}\in N$
  - 若考虑暴力求解不定方程,解的个数是阶乘级别的
  - Stirling公式:$n!=\sqrt{2\pi n}(\frac{n}{e})^n(1+\theta(\frac{1}{n}))$
- 汉诺塔问题及其变种
- 排序问题
- 货郎问题
  - 图上的问题
  - 大概是找最短欧拉回路
  - 目前没找到有效算法,存在大量问题与他难度等价
#### 算法
##### 非形式定义
- 有限条指令的序列
- 确定了解决某个问题的运算或操作
- 输入个数大于等于0
- 输出个数大于0
##### 形式定义
对所有的有效输入停机的Turing机
##### 算法A解问题P
把问题P的任何实例作为算法A的输入，A能够在有限步停机，并输出该实例的正确的解
#### 算法的描述:伪码
- 保持程序的主要结构
  - 类C,Pascal
  - 赋值语句:←
  - 分支语句:if...then...(else...)
  - 循环语句:while,for,repeat...until...
  - 转向语句:goto
  - 调用
  - 注释://...
- 允许使用自然语言
- 常忽略数据结构,模块,异常处理等细节
- 常忽略变量说明
- 不用分号,要缩进
```
实例:
Euclid(m,n)
输入:非负整数m,n,期中m与n不全为0
输出:m与n的最大公约数
1.while m>0 do
2.  r←n mod m
3.  nm
4.  mr
5.return n
```
#### 算法的时间复杂度
##### 最坏情况下
输入规模为n的实例所需的最长时间**W(n)**
##### 平均情况下
输入规模为n的实例所需的平均时间**A(n)=$\sum_{I\in S}t_{I}p_{I}$**
S:实例集,t~I~:实例I的基本运算次数,p~I~:I的概率
##### 复杂度表示
针对问题选择基本运算(比较or加减乘除?)
将基本运算次数表示为输入规模的函数

### 1.3 数学基础
#### 函数渐进的界

##### 设函数f和g是定义在正整数集N上的函数
1. \( f(n) = O(g(n)) \)
若存在正实数c和n0，使得对一切\( n \geq n0 \)有\( 0 \leq f(n) \leq cg(n) \)
2. \( f(n) = \Omega(g(n)) \)
若存在正实数c和n0，使得对一切\( n \geq n0 \)有\( 0 \leq cg(n) \leq f(n) \)
3. \( f(n) = o(g(n)) \)
若对于任意实数c>0存在n0，使得对一切\( n \geq n0 \)有\( 0 \leq f(n) < cg(n) \)
4. \( f(n) = \omega(g(n)) \)
若对于任意实数c>0存在n0，使得对一切\( n \geq n0 \)有\( 0 \leq cg(n) < f(n) \)
5. \( f(n) = \Theta(g(n)) \) \( \Leftrightarrow f(n) = O(g(n)) \) 且 \( f(n) = \Omega(g(n)) \)
6. \( O(1) \)表示常数级复杂度

##### 设函数f和g是定义在正整数集N上的函数。
1. 如果极限 \( \lim_{n \to \infty} \frac{f(n)}{g(n)} = c (c>0) \) 存在，则称 \( f(n) = O(g(n)) \)
2. 如果极限 \( \lim_{n \to \infty} \frac{f(n)}{g(n)} = 0 \)，则称 \( f(n) = o(g(n)) \)
3. 如果极限 \( \lim_{n \to \infty} \frac{f(n)}{g(n)} = +\infty \)，则称 \( f(n) = \omega(g(n)) \)

##### 注意事项
- 复杂度函数一般是正数
- 大写的O和Ω表示不排除θ,而小写的表示严格低于或高于
- 自然,以上性质具有传递性,可加减性
#### 基本函数类
##### 阶的高低
- 至少指数级：\(2^n, 3^n, n!, \ldots\)
- 多项式级：\(n, n^2, n\log n, n^{1/2}, \ldots\)
- 对数多项式增长：\(\log n, (\log n)^2, \ldots\)
##### 常见的函数
\(2^{2^n}>n!>n2^n>\left(\frac{3}{2}\right)^n>(\log n)^{\log n} = \Theta(n^{\log\log n})\) > \(n^3, \log (n!) = \Theta(n\log n)>n = 2^{\log n}\)>\(\log^2 n> \log n>\sqrt{\log n}>\log\log n>n^{\frac{1}{\log n}} = \Theta(1)\)
##### 不同复杂性类的基本层次结构
![alt text](/static/mdfiles/images/image-3.png)
#####算法及计算复杂性理论的拓广
- 算法
  - 概率算法
  - 近似算法
  - 在线算法
  - 分布式算法
- 计算复杂性
  - 概率Turing机与概率复杂性
  - 近似求解的复杂性参数复杂性
  - 计数复杂性
  - 通信复杂性
#### 其他一些和式求值放缩方法同高中，不再介绍
#### 递推方程
##### 求解方法
- 迭代法
  - 直接迭代
    - 如汉诺塔：$T(n)=2T(n-1)+1$
    - 如插入排序最坏：$W(n)=W(n-1)+n-1$
  - 换元迭代
    - 如二分归并排序最坏：$W(n)=2W(n/2)+n-1,W(1)=0$
    - 换元主要指的是n换成2^k^
  - 差消迭代
    - 如快排平均：$T(n)=\frac{2}{n}\sum^{n-1}_{i=1}+O(n),n\geq2,T(1)=0$
    - 主要是遇到求和号时
- 迭代模型：递归树
  - 把余项写到树节点位置
  - 子树是子问题
  - 最后对所有节点求和
- 尝试法
  - 如快排平均
  - 挨个假设$T(n)=cn,cnlogn,cn^{2}$,然后判断左右是否在$\Theta$意义下相等
  - 遇到$\lfloor x \rfloor$或$\lceil x \rceil$时先忽略取整号估计递推关系的阶，然后数学归纳法证明
- 主定理
  - 设\(a \geq 1\), \(b > 1\)为常数，\(f(n)\)为函数，\(T(n)\)为非负整数函数，且\(T(n) = aT(\frac{n}{b}) + f(n)\)则有以下三种情况:
    - 若\(f(n) = O(n^{\log_b{a-\epsilon}}), \epsilon > 0\), 则有\(T(n) = \Theta(n^{\log_b{a}})\)
    - 若\(f(n) = \Theta(n^{\log_b{a}})\), 则有\(T(n) = \Theta(n^{\log_b{a}} \log n)\)
    - 若\(f(n) = \Omega(n^{\log_b{a+\epsilon}}), \epsilon > 0\), 且对于某个常数\(c < 1\)和充分大的\(n\)有\(af(n/b) \leq cf(n)\), 则有\(T(n) = \Theta(f(n))\)
  - 不能用主定理的时候用递归树

## 第二章 分治策略
### 2.1 分治策略Divide & Cumquer
#### 基本思想
##### 顺序算法的设计技术
- 分治策略
- 动态规划算法
- 回溯法与分支估界
- 贪心算法
- 概率算法
##### 实例
- 二分检索
- 归并排序
##### 主要思想
- 划分divide
- 求解子问题conquer
- 综合解merge
```
Divide-and-Conquer(P)
1. if |P|≤c then S(P).
2. divide P into P_1, P_2,..., P_k.
3. for i = 1 to k
4.   y_i = Divide-and-Conquer(P_i)
5. Return Merge(y_1, y_2,..., y_k)
```
#### 复杂度求解
##### 分析工具：递推方程
- $f(n)=\sum^{k}_{i=1}f(n-i)+g(n)$
- $f(n)=af(\frac{n}{b})+d(n)$
##### 求解方法
- 迭代法
- 递归树
- Master定理
##### 典型的递推方程$f(n)=af(\frac{n}{b})+d(n)$
- 当d(n)当 \( d(n) \) 为常数时：\( f(n) = \begin{cases} O(n^{\log_b a}) & a \neq 1 \\O(\log n) & a = 1\end{cases}\)
- 当 \( d(n) = cn \) 时：\( f(n) = \begin{cases} O(n) & a < b \\O(n\log n) & a = b \\O(n^{\log_b a}) & a > b\end{cases}\)
##### 实例1：芯片测试
| A报告 | B报告 | 结论          |
|-------|-------|---------------|
| B是好的 | A是好的 | A,B都好或都坏 |
| B是好的 | A是坏的 | 至少一片是坏的 |
| B是坏的 | A是好的 | 至少一片是坏的 |
| B是坏的 | A是坏的 | 至少一片是坏的 |

条件：有n片芯片(好芯片至少比坏芯片多1片)
问题：使用最少的测试次数，从中挑出1片好芯片
要求：说明测试算法，进行复杂度分析
```
1.  k←n
2.  while k>3 do
3.    将芯片分成⌊k/2⌋组
4.    for i=1 to ⌊k/2⌋ do
5.      if 2片好，则任取1片留下
6.      else 2片同时丢弃
7.      k←剩下的芯片数
8.  if k=3
9.    then 任取2片芯片测试
10.     if 至少1坏，取没测的芯片
11.     else 任取1片被测芯片
12. if k=2 or 1 then 任取1片
```
**关键在于总能保证好的比坏的多**
**注意**，当n是偶数的时候满足上面的算法，当n是奇数时有一个芯片被轮空，如果轮空的是坏芯片的话，最后可能好坏个数一样。可以在一开始就把这个轮空的芯片和其他所有芯片进行测试（因为其他所有芯片好的多，所以测试结果取多数者），复杂度为O(n)
故时间复杂度$W(n)=W(n/2)+O(n),W(1)=0$,由主定理，$W(n)=O(n)$

##### 实例2：求自然数的幂
问题：计算a^n^,n为自然数
传统算法：$\Theta(n)$
分治法：\( a^n = \begin{cases} a^{\frac{n}{2}} \times a^{\frac{n}{2}}, & n\text{为偶数} \\ a^{\frac{n-1}{2}} \times a^{\frac{n-1}{2}} \times a, & n\text{为奇数} \end{cases} \)
\( T(n) = T\left(\frac{n}{2}\right) + \Theta(1) \Rightarrow T(n) = \Theta(\log n) \).
**斐波那契数列也可以变成2×2矩阵的幂乘，由$\Theta(n)$降到了$\Theta(logn)$**
### 2.2 提高算法效率的途径
#### 方法一：代数变换，减少子问题个数
##### 位乘问题
设X,Y是两个\( n \)位二进制数，\( n = 2^k \)，求XY.
- 传统算法 \( W(n)=O(n^2) \)
- 分治法
令\( X = A2^{n/2} + B, Y = C2^{n/2} + D. \)
\( XY = AC2^n + (AD + BC)2^{n/2} + BD \)
\( W(n) = 4W(n/2) + cn, \)
\( W(1) = 1 \)
解：\( W(n) = O(n^{\log_4}) = O(n^2) \)
- 代数变换
  \( AD + BC = (A - B)(D - C) + AC + BD \)
\( W(n) = 3W(n/2) + cn \)
\( W(1) = 1 \)
解：\( W(n) = O(n^{\log_3}) = O(n^{1.59}) \)
##### 矩阵乘法
完全类似的，把一个矩阵拆成四部分并不能有效降低复杂度，需要巧妙地拆
- 不巧妙的拆：
  - ![alt text](/static/mdfiles/images/image-4.png)
  - $W(n)=8W(n/2)+cn^2$


## 第四章 贪心算法
### 基本思想
#### 活动选择问题

### 算法设计
### 得不到最优解的处理办法
### 应用实例
